fibonacci
################################################################################

:Date: 2019-12-02 18:35
:Modified: 2019-12-02 19:00
:Category: memo
:Tags: go, golang, memo, algorthms, dynamic programming, recursion
:Author: Hideo Suzuki
:Summary: フィボナッチ数の計算。本とかでふむふむと理解したつもりで、実際に手を動かしてみると……

Trigger
================================================================================

とある会社の仕事しようとエントリーしたらスキルテストが送付されてきまして

Problem
--------------------------------------------------------------------------------

nが正の整数のとき、以下を満たす関数があります。

.. math::

   f(0)&= 0 \\
   f(1)& = 1\\
   f(n)& = f(n - 1) + f(n - 2)

#. :math:`f(n)` を求めるプログラムを作成してください。（言語は得意なもので結構です。）


#. 作成したのプログラムを使って :math:`f(8181)` を求めてください。


さて、解いてみましょう。

TL;DR
================================================================================

- トップダウン式動的計画法とメモ化で計算量を :math:`O(n)` に抑える

  - :math:`fib(n)` の計算結果を単にキャッシュしておく

- uint64やfloat64だとオーバーフローしてしまうので、 任意精度の演算（大きな数値）の実装の `math/big <https://golang.org/pkg/math/big/>`_ を使う


.. code-block:: go

   package main

   import (
           "fmt"
           "math/big"
   )
   
   func f(n int) *big.Int {
           var limit big.Int
           limit.Exp(big.NewInt(10), big.NewInt(99), nil)
           dp := make(map[int]*big.Int, n)
   
           return fib(n, dp)
   
   }
   
   func f(n int, dp map[int]*big.Int) *big.Int {
   
           if n == 0 {
                   return big.NewInt(0)
           } else if n == 1 {
                   return big.NewInt(1)
           }
   
           var ans big.Int
           if _, ok := dp[n]; !ok {
                   ans.Add(f(n-1, dp), f(n-2, dp))
                   dp[n] = &ans
           }
           return dp[n]
   }
   
   func main() {
           n := 8181
           fmt.Println(f(n))
   }


.. code-block:: go

   package main
   
   import (
   	"fmt"
   	"math/big"
   	"testing"
   )
   
   var ansS8181 = "239001090710360059034248200673803309562195124933438825088385870209105768309267224930066773271004303009695857056812050426322722227488483596969330539198412751609689113829755775066752844437629935556689908621747058520170917953833076673228939285877150494526386620300621280749499924952199516712960736433814553231958282333619656314497995824452475174641352224677997408976231194557854106641619031011172157654286916061043356523159334857136487352779804235483277506977454306460042287968212874761824582897118739286429568840003151050106146828835563160817912048376040050029809912293013734791567749471727392937824065261113177259783202662957881148637632338195187490758787735996699022778723575367214258563034452504094360966531897568256418608645465915444745840473934322871426418866598642747848660145342643755366760919516317387477526541252807114293921792114970905075434450564838742451198888345673434700068960962172644679947794329807611771708249033661865248799511661306285140477533559743999464574932871122125066107105911374614630965320293086278694399936369060752395531165804412176996135810584035128447884802662630006754418904791563798389799016017336123177492245220148295507234160487497059285034564989541608419857951981398972834439558266427410836592525389894745439937417033358839088886819050208294080514041113275997534122520735761635971975621605403703050984275628628811283403426936742851082726036123336764016240562071825096262121405587203818756266733130406345518134166312225673215071500009165695469591411166981267241101113735558997083171850461315680070428706983814819412637005375477590183910679020180492817106735246177201410250973608332090435177967936901320342366183865669056306257798108871942566285065496557591483743343454453933506"
   
   var ans8181, _ = new(big.Int).SetString(ansS8181, 10)
   
   var cases = []struct {
   	id    int
   	input int
   	want  *big.Int
   }{
   	{id: 1, input: 0, want: big.NewInt(0)},
   	{id: 2, input: 1, want: big.NewInt(1)},
   	{id: 3, input: 2, want: big.NewInt(1)},
   	{id: 4, input: 8181, want: ans8181},
   }
   
   func TestF(t *testing.T) {
   	for _, tt := range cases {
   		t.Run(fmt.Sprint(tt.id), func(t *testing.T) {
   			got := f(tt.input)
   			if got.Cmp(tt.want) != 0 {
   				t.Errorf("%g, want: %g", got, tt.want)
   			}
   		})
   	}
   }
   
   func Example_main() {
   	main()
   
   	// Output: 239001090710360059034248200673803309562195124933438825088385870209105768309267224930066773271004303009695857056812050426322722227488483596969330539198412751609689113829755775066752844437629935556689908621747058520170917953833076673228939285877150494526386620300621280749499924952199516712960736433814553231958282333619656314497995824452475174641352224677997408976231194557854106641619031011172157654286916061043356523159334857136487352779804235483277506977454306460042287968212874761824582897118739286429568840003151050106146828835563160817912048376040050029809912293013734791567749471727392937824065261113177259783202662957881148637632338195187490758787735996699022778723575367214258563034452504094360966531897568256418608645465915444745840473934322871426418866598642747848660145342643755366760919516317387477526541252807114293921792114970905075434450564838742451198888345673434700068960962172644679947794329807611771708249033661865248799511661306285140477533559743999464574932871122125066107105911374614630965320293086278694399936369060752395531165804412176996135810584035128447884802662630006754418904791563798389799016017336123177492245220148295507234160487497059285034564989541608419857951981398972834439558266427410836592525389894745439937417033358839088886819050208294080514041113275997534122520735761635971975621605403703050984275628628811283403426936742851082726036123336764016240562071825096262121405587203818756266733130406345518134166312225673215071500009165695469591411166981267241101113735558997083171850461315680070428706983814819412637005375477590183910679020180492817106735246177201410250973608332090435177967936901320342366183865669056306257798108871942566285065496557591483743343454453933506
   
   }
   
   func BenchmarkF(b *testing.B) {
   	for i := 0; i < b.N; i++ {
   		f(i)
   	}
   }



Process
================================================================================

**言語は得意なもので結構です。** との事ですので、最近書き続けているGoで書きます。

recursion
--------------------------------------------------------------------------------

問題にある関数をそのままコーディング。

https://play.golang.org/p/qXsDDWiHTHd

小さい数なら問題ありませんが、:math:`n = 100` でダメ。8181は遠い。

https://play.golang.org/p/5pZIZxJexVw

dynamic programming
--------------------------------------------------------------------------------

同じ計算を再度繰り返すのはコストがかかるので、計算結果をキャッシュしておいて再利用する動的計画法とメモ化を使います。

.. note: トップダウンの動的計画法を *メモ化* 、ボトムアップの処理のみの場合に *動的計画法* と呼ぶ人もいるそうですが、参考にした `世界で闘うプログラミング力を鍛える本 ~コーディング面接189問とその解法~ <https://www.amazon.co.jp/dp/4839960100/ref=cm_sw_em_r_mt_dp_U_USo5Db4M1J5P3>`_ では、区別せず、動的計画法と呼ぶ事にしますと用語メモに注釈されていましたのでその用語のまま使っています

https://play.golang.org/p/GmupThQeo_V

**Program exited: process took too long.** は出なくなりましたが、値が負の値が出ています。明らかにおかしいです。

float64
--------------------------------------------------------------------------------

オーバーフローしているので、float64を使います。

https://play.golang.org/p/I1w2ZfDa55X

実行結果は、*+Inf** : 正の無限大となり数値が出せません。


uint64
--------------------------------------------------------------------------------

何を血迷ったか、uint64なら上手くいくかな思って試しました。

https://play.golang.org/p/-S4owe9Q-kM

正の整数が出ていますが、果たしてこの値は正しいのでしょうか。

そう思い、フィボナッチ数を計算できるサイト `フィボナッチ数 - 高精度計算サイト <https://keisan.casio.jp/exec/system/1161228773>`_ を見つけ、計算した結果、明らかに値が違います。

やはり血迷ってました。

math/big
--------------------------------------------------------------------------------

任意精度の演算（大きな数値）の実装の `math/big <https://golang.org/pkg/math/big/>`_ を利用します。

このパッケージのドキュメントに `Example(Fibonacci) <https://golang.org/pkg/math/big/#example__fibonacci>`_ があったので参考にします。

https://play.golang.org/p/oAEmcTRqCFv

良さげです。計算結果も、`フィボナッチ数 - 高精度計算サイト <https://keisan.casio.jp/exec/system/1161228773>`_ の結果と同じ感じです。

SeeAlso
================================================================================

- `世界で闘うプログラミング力を鍛える本 ~コーディング面接189問とその解法~ <https://www.amazon.co.jp/dp/4839960100/ref=cm_sw_em_r_mt_dp_U_USo5Db4M1J5P3>`_
- `フィボナッチ数 - 高精度計算サイト <https://keisan.casio.jp/exec/system/1161228773>`_
